
using DynamicExcelIO.Exceptions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace DynamicExcelIO.ClassCreator
{
    public class TypeExtender
    {
        /// <summary>
        /// Instantiantes a TypeExtender class that starts extending System.Object class
        /// </summary>
        /// <param name="className">Name of the new class that extends System.Object</param>
        public TypeExtender(string className) : this(typeof(object), className)
        {
        }

        /// <summary>
        /// Instantiates a TypeExtender class that starts extending a given base class
        /// </summary>
        /// <param name="baseClassType">The type of the base class to be extended</param>
        /// <param name="className">Name of the new class that extends the baseClassType</param>
        public TypeExtender(Type baseClassType, string className)
        {
            Ancestor = baseClassType;
            _className = className;
        }

        /// <summary>
        /// Returns the Type of created class (sub-type)
        /// </summary>
        /// <returns>Type of the sub-type</returns>
        public Type FetchType()
        {
            if (_typeBuilder == null)
            {
                throw new TypeNotCreatedException(_className);
            }
            return _typeBuilder.CreateType();
        }

        public void Refresh()
        {
            _typeBuilder = null;
        }

        /// <summary>
        /// Adds a property to the class being extended or created
        /// </summary>
        /// <typeparam name="T">Return type of the property</typeparam>
        /// <param name="propertyName">Name of the property to be added</param>
        /// <param name="isReadOnly">Indicates if the property is ReadOnly</param>
        public void AddProperty<T>(string propertyName, bool isReadOnly = false)
        {
            AddProperty(propertyName, typeof(T),isReadOnly: isReadOnly);
        }

        /// <summary>
        /// Adds a property with a custom attribute to the class being extended or created
        /// </summary>
        /// <typeparam name="Tproperty">Return type of the property</typeparam>
        /// <typeparam name="Tattr">Type of the custom Attribute</typeparam>
        /// <param name="propertyName">Name of the property to be added</param>
        /// <param name="isReadOnly">Indicates if the property is ReadOnly</param>
        public void AddProperty<Tproperty,Tattr>(string propertyName, bool isReadOnly) {
            AddProperty(propertyName, typeof(Tproperty), typeof(Tattr), isReadOnly);
        }

        /// <summary>
        /// Adds a property to the class being extended or created
        /// </summary>
        /// <param name="propertyName">Name of the property to be added</param>
        /// <param name="propertyType">Return type of the property</param>
        /// <param name="attributeType">type of the custom attribute</param>
        /// <param name="isReadOnly">Indicates if the property is ReadOnly</param>
        public void AddProperty(string propertyName, Type propertyType, Type attributeType=null, bool isReadOnly = false)
        {
            if (string.IsNullOrWhiteSpace(propertyName))
            {
                throw new ArgumentException("propertyName can not be null or empty");
            }

            addProperty(propertyName, propertyType,attributeType, isReadOnly);
        }


        /// <summary>
        /// Adds a collection of properties with the same type to the class being extended or created
        /// </summary>
        /// <typeparam name="T">The return type of all the properties in the collection</typeparam>
        /// <param name="propertyNames">A collection that holds the names of the properties to be added</param>
        public void AddProperty<T>(IEnumerable<string> propertyNames)
        {
            AddProperty(propertyNames, typeof(T));
        }

        /// <summary>
        /// Adds a collection of properties with the same type to the class being extended or created
        /// </summary>
        /// <param name="propertyNames">A collection that holds the names of the properties to be added</param>
        /// <param name="propertyType">The return type of all the properties in the collection</param>
        public void AddProperty(IEnumerable<string> propertyNames, Type propertyType)
        {
            if (propertyNames == null || propertyNames.Count() < 1)
            {
                throw new ArgumentException("Properties can not be null or empty");
            }

            addProperties(propertyNames, propertyType);
        }

        /// <summary>
        /// Adds a collection properties with separate data type to the class being extended or created
        /// </summary>
        /// <param name="properties">A collection that holds the names of the properties to be added</param>
        /// <param name="types">A collection that holds the types of the properties to be added</param>
        public void AddProperty(IEnumerable<string> properties, IEnumerable<Type> types)
        {
            if(properties==null || types==null || !properties.Any() || !types.Any())
            {
                throw new ArgumentException("Properties or types can not be null or empty");
            }

            if (properties.Count() != types.Count())
            {
                throw new ArgumentException("Properties count must equal types count to avoid type mis-match");
            }

            for (int index = 0; index < properties.Count(); index++)
            {
                addProperty(properties.ElementAt(index), types.ElementAt(index),null, false);
            }
        }

        private void addProperties(IEnumerable<string> properties, Type propertyType)
        {
            initializeTypConstruction();
            foreach (var prop in properties)
            {
                var field = _typeBuilder.DefineField($"_{prop}", propertyType, FieldAttributes.Private);
                var property = _typeBuilder.DefineProperty(prop, PropertyAttributes.HasDefault, propertyType, null);
                generateGetter(prop, field, property, propertyType);
                generateSetter(prop, field, property, propertyType);
            }
        }

        private void addProperty(string propertyName, Type type, Type attributeType, bool isReadOnly)
        {
            initializeTypConstruction();
            var field = _typeBuilder.DefineField($"_{propertyName}", type, FieldAttributes.Private);
            var propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, type, null);
            if (attributeType != null) {
                var attrCtorInfo = attributeType.GetConstructor(new Type[] { });
                var attrBuilder = new CustomAttributeBuilder(attrCtorInfo, new object[] { });
                propertyBuilder.SetCustomAttribute(attrBuilder);
            }
            generateGetter(propertyName, field, propertyBuilder, type);

            if (!isReadOnly)
            {
                generateSetter(propertyName, field, propertyBuilder, type);
            }
        }

        private void generateSetter(string propertyName, FieldBuilder field, PropertyBuilder propertyBuilder, Type paramType)
        {
            var setMethodBuilder = _typeBuilder.DefineMethod($"set_{propertyName}", _getSetAttr, typeof(void), new Type[] { paramType });
            var setMethodGenerator = setMethodBuilder.GetILGenerator();
            setMethodGenerator.Emit(OpCodes.Ldarg_0);
            setMethodGenerator.Emit(OpCodes.Ldarg_1);
            setMethodGenerator.Emit(OpCodes.Stfld, field);
            setMethodGenerator.Emit(OpCodes.Ret);
            propertyBuilder.SetSetMethod(setMethodBuilder);
        }

        private void generateGetter(string propertyName, FieldBuilder field, PropertyBuilder propertyBuilder, Type returnType)
        {
            var getMethodBuilder = _typeBuilder.DefineMethod($"get_{propertyName}", _getSetAttr, returnType, null);
            var getMethodGenerator = getMethodBuilder.GetILGenerator();
            getMethodGenerator.Emit(OpCodes.Ldarg_0);
            getMethodGenerator.Emit(OpCodes.Ldfld, field);
            getMethodGenerator.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getMethodBuilder);
        }

        private void initializeTypConstruction()
        {
            if (!Ancestor.Attributes.HasFlag(TypeAttributes.Public) || Ancestor.Attributes.HasFlag(TypeAttributes.Sealed))
            {
                throw new AncestorNotExtendableException(Ancestor.Name);
            }

            if (_typeBuilder!=null && _typeBuilder.IsCreated())
            {
                throw new TypeHasBeenCreatedException(_typeBuilder.Name);
            }

            if (_typeBuilder != null)
            {
                return;
            }

            _assemblyName = new AssemblyName("DynamicAssembly");
            _assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(_assemblyName, AssemblyBuilderAccess.Run);
            _moduleBuilder = _assemblyBuilder.DefineDynamicModule(_assemblyName.Name);
            _typeBuilder = _moduleBuilder.DefineType(_className, TypeAttributes.Public, Ancestor);
        }

        public Type Ancestor { get; }

        private string _className;
        private AssemblyName _assemblyName;
        private AssemblyBuilder _assemblyBuilder;
        private ModuleBuilder _moduleBuilder;
        private TypeBuilder _typeBuilder;
        private MethodAttributes _getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig;
    }
}
